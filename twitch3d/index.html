<!DOCTYPE html>
<html>
    <head>
        <title>Twitch 3D</title>
        <meta charset="utf-8">
        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600&display=swap" rel="stylesheet">
        <link href="https://hjjg200.github.io/fonts/GmarketSans/GmarketSans.css" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">

        <style>
* {
    appearance: none;
    -moz-appearance: none;
    -webkit-appearance: none;
    -ms-appearance: none;
    box-sizing: border-box;
    text-size-adjust: none;
    -webkit-text-size-adjust: 100%;

    margin: 0;
    padding: 0;
    outline: none;
    border: none;
}

html, body {
    background: black;
    font-size: 16px;
    font-family: Roboto, Helvetica, Arial, sans-serif;
    line-height: 1.5;
    overflow: hidden;
    width: 100vw;
    height: 100vh;
}
body.lang-ko {
    font-family: 'Noto Sans KR', sans-serif;
}

h1, h2, h3, h4 {
    font-family: Poppins, sans-serif;
}
body.lang-ko h1,
body.lang-ko h2,
body.lang-ko h3,
body.lang-ko h4 {
    font-family: 'Gmarket Sans', sans-serif;;
    font-weight: 400;
}

main {
    width: 100%;
    height: 100%;
}

button {
    border: none;
    outline: none;
    color: white;
    background: #9146FF;
    font-weight: bold;
    font-size: .8rem;
    padding: .4rem .7rem;
    border-radius: .3rem;
}

button:hover {
    background: rgb(166, 107, 255);
}

iframe {
    pointer-events: none;
}

input[type='text'] {
    background: rgba(0, 0, 0, 0.1);
    border-radius: .3rem;
    padding: .4rem .6rem;
}
input[type='text']:hover {
    box-shadow: 0 0 0 .125rem rgba(0, 0, 0, 0.15) inset;
}
input[type='text']:focus {
    box-shadow: 0 0 0 .125rem #9146FF inset;
    background: white;
}

/* Specific */

body.still-cursor main {
    cursor: none !important;
}

button.button-cancel {
    background: rgba(0, 0, 0, 0.1);
    color: #444;
}
button.button-cancel:hover {
    background: rgba(0, 0, 0, 0.15);
}

div.frame > * {
    display: inline-block;
}
div.frame.frame-ralign {
    text-align: right;
}

#introduction {
    color: white;
    font-size: 1.2rem;
    width: 24rem;
    height: fit-content;
    top: 50%;
    left: 50%;
    position: absolute;
    transform: translate(-50%, -50%);
}

.stream {
    background: gray;
    position: absolute;
}
.stream-content {
    width: 100%;
    height: 100%;
    position: relative;
}
.stream.enable-iframe {
    box-shadow: 0 0 0 4px rgba(92, 152, 255, 0.55); /* visual hint */
}
.stream.enable-iframe .video-overlay {
    pointer-events: none;
}
.stream.enable-iframe iframe {
    pointer-events: all;
}
.stream .video-overlay {
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    position: absolute;
}
.stream .title-bar,
.stream .title {
    top: 0;
    left: 0;
    width: 100%;
    height: 1.75rem;
    user-select: none;
    -webkit-user-select: none;
}
.stream .title-bar {
    color: white;
    background: #9146FF;
    font-size: .8rem;
    position: absolute;
    opacity: 1;
    transition: opacity 0.5s cubic-bezier(0.075, 0.82, 0.165, 1);
}
.stream:not(.in-move):not(.in-resize) .title-bar:not(:hover) {
    opacity: 0;
}
.stream .title-bar .title {
    display: block;
    line-height: 1.75rem;
    text-align: center;
    user-select: none;
}
.stream .title-bar button {
    border-radius: 0;
    color: white;
    font-size: 1.8rem;
    line-height: .6rem;
    overflow: hidden;
    font-weight: normal;
    height: 1.75rem;
    width: 3.5rem;
    display: inline-block;
    position: absolute;
}
.stream .title-bar .controls:hover button {
}
.stream .title-bar .btn-maximize {
    top: 0;
    right: 3.5rem;
    font-size: 1.6rem;
    line-height: .55rem;
}
.stream .title-bar .btn-close {
    top: 0;
    right: 0rem;
}
.stream.maximized {
    top: 0 !important;
    left: 0 !important;
    width: 100% !important;
    height: 100% !important;
    z-index: 0 !important;
    transform: none !important;
}
.stream:not(.focused) .corner,
.stream.maximized .corner,
.stream.in-move .corner {
    display: none;
}
.stream .corner {
    width: 1.2rem;
    height: 1.2rem;
    position: absolute;
    transform: translate(-50%, -50%);
}
.stream .corner-top,
.stream .corner-bottom {
    cursor: ns-resize;
    width: calc(100% - 1.2rem);
    height: 0.4rem;
}
.stream .corner-right,
.stream .corner-left {
    cursor: ew-resize;
    width: 0.4rem;
    height: calc(100% - 1.2rem);
}
.stream .corner-top {
    left: 50%;
    top: 0;
}
.stream .corner-right {
    left: 100%;
    top: 50%;
}
.stream .corner-bottom {
    left: 50%;
    top: 100%;
}
.stream .corner-left {
    left: 0;
    top: 50%;
}
.stream .corner-top-left,
.stream .corner-bottom-right {
    cursor: nwse-resize;
}
.stream .corner-top-right,
.stream .corner-bottom-left {
    cursor: nesw-resize;
}
.stream .corner-top-left {
    left: 0;
    top: 0;
}
.stream .corner-top-right {
    left: 100%;
    top: 0;
}
.stream .corner-bottom-right {
    left: 100%;
    top: 100%;
}
.stream .corner-bottom-left {
    left: 0;
    top: 100%;
}
.stream:not(.focused) iframe {
    pointer-events: none;
}
.stream .iframe-container,
.stream iframe {
    height: 100%;
    width: 100%;
    outline: none;
    border: none;
}

#context-menu {
    box-shadow: 0 0 .8rem rgba(0, 0, 0, 0.3);
    display: none;
    width: fit-content;
    background: white;
    position: absolute;
    z-index: 2001;
    overflow: hidden;
    padding: 0;
    border-radius: .2rem;
}
#context-menu-content {
    position: relative;
}
#context-menu ul {
    list-style: none;
}
#context-menu ul li {
    display: block;
}
#context-menu button {
    background: none;
    border-radius: 0;
    color: #444;
    display: block;
    width: 100%;
    height: 100%;
    line-height: 1;
    font-size: .85rem;
    padding: .5rem 4rem .5rem .6rem;
    font-weight: normal;
    text-align: left;
}
#context-menu button:hover {
    background: #9146FF;
    color: white;
}
body.fullscreen #btn-fullscreen,
body:not(.fullscreen) #btn-exit-fullscreen {
    display: none;
}

.modal {
    background: rgba(255, 255, 255, 0.2);
    display: none;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 2000;
}
.modal-content {
    background: white;
    position: relative;
    font-size: .8rem;
    padding: 1rem;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: fit-content;
}

.modal-buttons {
    margin-top: 1rem;
}

#add-stream-modal input {
    width: 15rem;
    margin-top: 3rem;
}
        </style>
    </head>
    <body>
        <main>
            <div id="introduction">
                <h1>This Is Twitch3D</h1>
                <p>Press <b>Right Mouse Button</b> to open up menu and add your favorite Twitch channels!</p>
                <div class="frame frame-ralign">
                </div>
            </div>
            <div id="streams-container">

            </div>
        </main>
        <div id="context-menu">
            <div id="context-menu-content">
                <ul id="context-menu-items">
                    <li>
                        <button id="btn-add-stream">Add Channel</button>
                    </li>
                    <li>
                        <button id="btn-fullscreen">Fullscreen</button>
                    </li>
                    <li>
                        <button id="btn-exit-fullscreen">Exit Fullscreen</button>
                    </li>
                    <li>
                        <button id="btn-github">GitHub</button>
                    </li>
                </ul>
            </div>
        </div>
        <div id="add-stream-modal" class="modal">
            <div class="modal-content">
                <h2>Add Channel</h2>
                <p>Enter the Twitch ID of the streamer</p>
                <div class="frame">
                    <input type="text">
                </div>
                <div class="frame frame-ralign modal-buttons">
                    <button class="button button-ok">OK</button>
                    <button class="button button-cancel">Cancel</button>
                </div>
            </div>
        </div>
        <script>

const lang = navigator.language.slice(0, 2);
const locales = {
    "ko": {
        "#introduction h1": "트위치3D",
        "#introduction p": "<b>오른쪽 마우스 버튼</b>으로 메뉴를 열어서 스트리머들을 추가해보세요!",
        "#btn-add-stream": "채널 추가",
        "#btn-fullscreen": "전체화면",
        "#btn-exit-fullscreen": "전체화면 나가기",
        "#add-stream-modal h2": "채널 추가",
        ".button-ok": "확인",
        ".button-cancel": "취소"
    }
};
if(locales[lang] !== undefined) {
    document.body.classList.add(`lang-${lang}`);
    for(const key in locales[lang]) {
        for(const el of document.querySelectorAll(key).values()) {
            el.innerHTML = locales[lang][key];
        }
    }
}

const streamsContainer = document.getElementById("streams-container");
const btnDebugAdd = document.getElementById("btn-debug-add");

const defaults = {
    streamWidth: "45rem",
    streamHeight: "30rem",
    streamTop: "6rem",
    streamLeft: "6rem",
    minWdith: "9rem",
    minHeight: "6rem",
    streamZIndex: "1",
    streamMaximized: false,
    streamTransform: "",
    streamLastBottom: "",
    streamLastRight: "",
    streamLastMT: "",
    streamLastML: ""
};

const pxToRem = (px) => {
    return px / parseFloat(getComputedStyle(document.documentElement).fontSize);
};

const remToPx = (rem) => {
    return rem * parseFloat(getComputedStyle(document.documentElement).fontSize);
};

const readRem = (sty) => {
    const str = sty.replace("rem", "");
    return parseFloat(str);
};

const readTranslateXY = (transform) => {
    if(transform === "") return [0, 0];
    const rmp = transform.slice(transform.indexOf("(") + 1, transform.indexOf(")"));
    const xy = rmp.split(/\s*,\s*/g).map(readRem);
    return xy;
};

const addPxToRem = (sty, px) => {
    if(px === 0) return sty;
    const p2r = pxToRem(px);
    const fl = readRem(sty) + p2r;
    return `${fl}rem`;
};

const hasParent = (elem, parent) => {
    let n = elem.parentNode;
    while(n !== null) {
        if(n === parent) return true;
        n = n.parentNode;
    }
    return false;
};

const hasParentSelector = (elem, selector) => {
    let n = elem.parentNode;
    while(n !== null && n.matches) {
        if(n.matches(selector)) return true;
        n = n.parentNode;
    }
    return false;
};

const createElement = (tag, ...classes) => {
    const element = document.createElement(tag);
    element.classList.add(...classes);
    return element;
};

// Menu
const ctxMenu = document.getElementById("context-menu");
const ctxItems = document.getElementById("context-menu-items");
const modals = document.querySelectorAll(".modal");
const addStreamModal = document.getElementById("add-stream-modal");
const btnAddStream = document.getElementById("btn-add-stream");
const btnFullscreen = document.getElementById("btn-fullscreen");
const btnExitFullscreen = document.getElementById("btn-exit-fullscreen");
const btnGitHub = document.getElementById("btn-github");
document.addEventListener("contextmenu", (ev) => {
    ev.preventDefault();
    ctxMenu.style.display = "block";
    ctxMenu.style.top = `${pxToRem(mouseY - 3)}rem`;
    ctxMenu.style.left = `${pxToRem(mouseX + 3)}rem`;
});
document.addEventListener("mousedown", (ev) => {
    if(!hasParent(ev.target, ctxMenu)) {
        ctxMenu.style.display = "";
    }
});
document.addEventListener("mouseup", (ev) => {
    const t = ev.target;
    if(!(t.matches(".modal-content") || hasParentSelector(t, ".modal-content"))
        && (t.matches(".modal") || hasParentSelector(t, ".modal"))) {
        for(const modal of modals.values()) {
            modal.style.display = "";
        }
    }
});
ctxItems.addEventListener("mouseup", (ev) => {
    ctxMenu.style.display = "";
});
btnAddStream.addEventListener("mouseup", (ev) => {
    addStreamModal.dispatchEvent(new Event("modalopen"));
});
btnFullscreen.addEventListener("mouseup", (ev) => {
    document.body.requestFullscreen();
});
btnExitFullscreen.addEventListener("mouseup", (ev) => {
    document.exitFullscreen();
});
btnGitHub.addEventListener("mouseup", (ev) => {
    window.open("https://github.com/hjjg200/hjjg200.github.io/tree/main/twitch3d", "_blank");
});
document.addEventListener("fullscreenchange", (ev) => {
    document.body.classList[document.fullscreenElement === null ? "remove" : "add"]("fullscreen");
});

const compensateTranslate = (stream) => {
    const txy = readTranslateXY(stream.style.transform);
    return [`${readRem(stream.style.top) + txy[1]}rem`, `${readRem(stream.style.left) + txy[0]}rem`];
};
const repositionStream = (stream) => {
    const wh = pxToRem(window.innerHeight);
    const ww = pxToRem(window.innerWidth);
    const [top, left] = compensateTranslate(stream);
    const bottom = wh - (readRem(top) + readRem(stream.style.height));
    const right = ww - (readRem(left) + readRem(stream.style.width));
    const mt = (readRem(top) + readRem(stream.style.height)/2) - wh/2;
    const ml = (readRem(left) + readRem(stream.style.width)/2) - ww/2;
    const lastBottom = readRem(stream.getAttribute("data-last-bottom"));
    const lastRight = readRem(stream.getAttribute("data-last-right"));
    const lastMT = readRem(stream.getAttribute("data-last-mt"));
    const lastML = readRem(stream.getAttribute("data-last-ml"));
    const xy = [0, 0];
    const tbMin = Math.min(lastBottom, readRem(top), Math.abs(lastMT));
    const lrMin = Math.min(lastRight, readRem(left), Math.abs(lastML));
    if(tbMin === lastBottom) xy[1] = -(lastBottom - bottom);
    else if(tbMin === Math.abs(lastMT)) xy[1] = (lastMT - mt);

    if(lrMin === lastRight)  xy[0] = -(lastRight - right);
    else if(lrMin === Math.abs(lastML)) xy[0] = (lastML - ml);

    const txy = readTranslateXY(stream.style.transform);
    stream.style.transform = `translate(${xy[0]+txy[0]}rem, ${xy[1]+txy[1]}rem)`;
};
let windowResizeTimeout = null;
window.addEventListener("resize", (event) => {
    if(windowResizeTimeout !== null) clearTimeout(windowResizeTimeout);
    windowResizeTimeout = setTimeout(() => {
        const streams = document.querySelectorAll(".stream");
        for(const stream of streams.values()) {
            repositionStream(stream);
        }
        updateStreamsCache();
    }, 100);
});

// Mouse tracker
let mouseX = 0;
let mouseY = 0;
let mouseThrottled = false;
let mouseHideHandler = null;
const mouseHandler = (event) => {
    if(mouseThrottled) return;
    mouseThrottled = true;
    document.body.classList.remove("still-cursor");
    mouseX = event.pageX;
    mouseY = event.pageY;
    if(mouseHideHandler !== null) {
        clearTimeout(mouseHideHandler);
    }
    mouseHideHandler = setTimeout(((x, y) => {
        if(mouseX === x && mouseY === y) document.body.classList.add("still-cursor");
    }).bind(null, mouseX, mouseY), 3000);
    setTimeout(() => {
        mouseThrottled = false;
    }, 16);
};
document.addEventListener("mousemove", mouseHandler);

// Stream-related

const cleanupZIndex = () => {
    const streams = document.querySelectorAll(".stream");
    const map = {};
    const ary = [];
    for(const stream of streams.values()) {
        const zi = stream.style.zIndex;
        map[zi] = stream;
        ary.push(parseInt(zi));
    }
    ary.sort();
    for(let i = 0; i < ary.length; i++) {
        map[`${ary[i]}`].style.zIndex = `${i + 1}`;
    }
};

let focusedStream = null;
let maximizedStream = null;

const blurStream = (stream) => {
    stream.classList.remove("focused");
    focusedStream = null;
};

const focusStream = (stream) => {
    if(focusedStream === stream) return;
    let oldStream = null;
    if(focusedStream !== null) {
        oldStream = focusedStream;
        blurStream(focusedStream);
    }
    focusedStream = stream;
    stream.classList.add("focused");
    stream.style.zIndex = "999";
    if(oldStream !== null) stream.style.zIndex = `${parseInt(oldStream.style.zIndex) + 1}`;
    cleanupZIndex();
};

const disableIframeStreams = () => {
    const streams = document.querySelectorAll(".stream.enable-iframe");
    for(const stream of streams.values()) {
        stream.classList.remove("enable-iframe");
    }
};

const enableIframeStream = (stream) => {
    disableIframeStreams();
    stream.classList.add("enable-iframe");
};

const unmaximizeStream = (stream) => {
    stream.classList.remove("maximized");
    maximizedStream = null;
};

const maximizeStream = (stream) => {
    disableIframeStreams();
    if(maximizedStream === stream) {
        unmaximizeStream(stream);
        return;
    } else {
        if(maximizedStream !== null) {
            unmaximizeStream(maximizedStream);
        }
        maximizedStream = stream;
        stream.classList.add("maximized");
    }
    updateStreamsCache();
    cleanupZIndex();
};

const closeStream = (stream) => {
    disableIframeStreams();
    stream.parentNode.removeChild(stream);
    updateStreamsCache();
};

const setLastBottomRight = (stream) => {
    const [top, left] = [stream.style.top, stream.style.left];
    const lb = pxToRem(window.innerHeight) - (readRem(top) + readRem(stream.style.height));
    const lr = pxToRem(window.innerWidth) - (readRem(left) + readRem(stream.style.width));
    const mt = (readRem(top) + readRem(stream.style.height)/2) - pxToRem(window.innerHeight / 2);
    const ml = (readRem(left) + readRem(stream.style.width)/2) - pxToRem(window.innerWidth / 2);
    stream.setAttribute("data-last-bottom", `${lb}rem`);
    stream.setAttribute("data-last-right", `${lr}rem`);
    stream.setAttribute("data-last-mt", `${mt}rem`);
    stream.setAttribute("data-last-ml", `${ml}rem`);
}

const snapPixel = 10;
const snapHelper = (origin, length, dest) => {
    const dist = pxToRem(snapPixel);
    if(origin + length >= dest - dist && origin + length <= dest + dist)
        return [true, dest - length, dest - origin];
    return [false];
};
const attemptSnap = (stream, top, left, height, width, tblr) => {
    const nt = readRem(top);
    const nl = readRem(left);
    const nh = readRem(height);
    const nw = readRem(width);
    let bt = nt, bl = nl, bh = nh, bw = nw;
    const wh = pxToRem(window.innerHeight);
    const ww = pxToRem(window.innerWidth);

    const tdests = [0];
    const bdests = [wh];
    const ldests = [0];
    const rdests = [ww];
    // Other streams
    for(const rhs of document.querySelectorAll(".stream").values()) {
        if(rhs === stream) continue;
        const rt = readRem(rhs.style.top);
        const rl = readRem(rhs.style.left);
        tdests.push(rt, rt + readRem(rhs.style.height));
        bdests.push(rt, rt + readRem(rhs.style.height));
        ldests.push(rl, rl + readRem(rhs.style.width));
        rdests.push(rl, rl + readRem(rhs.style.width));
    }

    const h = (origin, length, dests) => {
        let ret = [false];
        for(let i = 0; i < dests.length; i++) {
            const [snapped, o, l] = snapHelper(origin, length, dests[i]);
            if(snapped) ret = [snapped, o, l];
        }
        return ret;
    };

    const [tws, two, twl] = h(nt, 0, tdests);
    if(tws) (bt = two) || tblr[0] && (bh = twl);
    const [bws, bwo, bwl] = h(nt, nh, bdests);
    if(bws) (bt = bwo) || tblr[1] && (bh = bwl);
    const [lws, lwo, lwl] = h(nl, 0, ldests);
    if(lws) (bl = lwo) || tblr[2] && (bw = lwl);
    const [rws, rwo, rwl] = h(nl, nw, rdests);
    if(rws) (bl = rwo) || tblr[3] && (bw = rwl);

    return [`${bt}rem`, `${bl}rem`, `${bh}rem`, `${bw}rem`];
};

let moveHandlers = [];
const startMove = (stream, event) => {
    disableIframeStreams();
    const startX = mouseX;
    const startY = mouseY;
    const [startTop, startLeft] = compensateTranslate(stream);
    if(maximizedStream === stream) return;
    stream.classList.add("in-move");
    let changed = false;
    moveHandlers.push(setInterval(() => {
        const dx = mouseX - startX;
        const dy = mouseY - startY;
        const oldChanged = changed;
        changed = changed || (dx !== 0 || dy !== 0);
        if(changed !== oldChanged) stream.style.transform = "";
        if(!changed) return;
        const leftLowerCap = readRem(stream.style.width) - 2;
        const leftUpperCap = pxToRem(window.innerWidth) - 2;
        const topUpperCap = pxToRem(window.innerHeight) - 2;
        let newTop = addPxToRem(startTop, dy);
        let newLeft = addPxToRem(startLeft, dx);
        newTop = readRem(newTop) < 0 ? "0rem" : newTop;
        newTop = readRem(newTop) > topUpperCap ? `${topUpperCap}rem` : newTop;
        newLeft = readRem(newLeft) < (-leftLowerCap) ? `${-leftLowerCap}rem` : newLeft;
        newLeft = readRem(newLeft) > leftUpperCap ? `${leftUpperCap}rem` : newLeft;
        [newTop, newLeft] = attemptSnap(stream, newTop, newLeft, stream.style.height, stream.style.width, [false, false, false, false]);
        stream.style.top = newTop;
        stream.style.left = newLeft;
        setLastBottomRight(stream);
    }, 16));
};
let resizeHandlers = [];
const snapRatio = 16 / 9;
const resizeSnapThreshold = 0.05;
const startResize = (stream, tbWise, lrWise, event) => {
    disableIframeStreams();
    // tbWise: 1 = top, 0 = none, -1 = bottom
    // lrWise: 1 = left, 0 = none, -1 = right
    const startX = mouseX;
    const startY = mouseY;
    const [startTop, startLeft] = compensateTranslate(stream);
    const startHeight = stream.style.height;
    const startWidth = stream.style.width;
    const minWidth = defaults.minWdith;
    const minHeight = defaults.minHeight;
    stream.classList.add("in-resize");
    let changed = false;
    resizeHandlers.push(setInterval(() => {
        const dx = mouseX - startX;
        const dy = mouseY - startY;
        const oldChanged = changed;
        changed = changed || (dx !== 0 || dy !== 0);
        if(changed !== oldChanged) stream.style.transform = "";
        if(!changed) return;
        let newHeight = addPxToRem(startHeight, dy * (-tbWise));
        let newWidth = addPxToRem(startWidth, dx * (-lrWise));
        let newTop = addPxToRem(startTop, dy);
        let newLeft = addPxToRem(startLeft, dx);

        let f_nw = readRem(newWidth);
        let f_nh = readRem(newHeight);
        const ratio = f_nw / f_nh;
        if(ratio <= snapRatio * (1+resizeSnapThreshold)
            && ratio >= snapRatio * (1-resizeSnapThreshold)) {
            if(lrWise !== 0 && tbWise === 0) {
                f_nw = (f_nh / 9) * 16;
                newWidth = `${f_nw}rem`;
                newLeft = `${readRem(startLeft) - (f_nw - readRem(startWidth))}rem`;
            } else {
                f_nh = (f_nw / 16) * 9;
                newHeight = `${f_nh}rem`;
                newTop = `${readRem(startTop) - (f_nh - readRem(startHeight))}rem`;
            }
        }

        if(readRem(newHeight) < readRem(minHeight)) {
            newHeight = `${readRem(minHeight)}rem`;
            newTop = `${readRem(startTop) + readRem(startHeight) - readRem(minHeight)}rem`;
        }
        if(readRem(newWidth) < readRem(minWidth)) {
            newWidth = `${readRem(minWidth)}rem`;
            newLeft = `${readRem(startLeft) + readRem(startWidth) - readRem(minWidth)}rem`;
        }
        [newTop, newLeft, newHeight, newWidth] = attemptSnap(stream, newTop, newLeft, newHeight, newWidth, [tbWise === 1, tbWise === -1, lrWise === 1, lrWise === -1]);
        stream.style.height = newHeight;
        stream.style.width = newWidth;
        if(tbWise === 1) stream.style.top = newTop;
        if(lrWise === 1) stream.style.left = newLeft;
        setLastBottomRight(stream);
    }, 16));
};
const stopMove = () => {
    if(moveHandlers.length === 0) return;
    for(const stream of document.querySelectorAll(".stream.in-move").values()) {
        stream.classList.remove("in-move");
    }
    for(let i = 0; i < moveHandlers.length; i++) clearInterval(moveHandlers[i]);
    moveHandlers = [];
    updateStreamsCache();
};
const stopResize = () => {
    if(resizeHandlers.length === 0) return;
    for(const stream of document.querySelectorAll(".stream.in-resize").values()) {
        stream.classList.remove("in-resize");
    }
    for(let i = 0; i < resizeHandlers.length; i++) clearInterval(resizeHandlers[i]);
    resizeHandlers = [];
    updateStreamsCache();
};

document.addEventListener("mouseup", stopMove);
document.addEventListener("mouseup", stopResize);

const updateStreamsCache = () => {
    const data = [];
    const streams = document.querySelectorAll(".stream");
    for(let i = 0; i < streams.length; i++) {
        const stream = streams[i];
        data.push({
            streamer: stream.getAttribute("data-streamer"),
            options: {
                streamWidth: stream.style.width,
                streamHeight: stream.style.height,
                streamTop: stream.style.top,
                streamLeft: stream.style.left,
                streamZIndex: stream.style.zIndex,
                streamMaximized: maximizedStream === stream,
                streamTransform: stream.style.transform,
                streamLastBottom: stream.getAttribute("data-last-bottom"),
                streamLastRight: stream.getAttribute("data-last-right"),
                streamLastMT: stream.getAttribute("data-last-mt"),
                streamLastML: stream.getAttribute("data-last-ml")
            }
        });
    }
    localStorage.setItem("t3d-data", JSON.stringify(data));
};

const addStream = (streamer, options) => {
    /*
    div.stream
        div.stream-content
            div.title-bar
                span.title
                div.controls
                    button.btn-maximize
                    button.btn-close
            div.corner.corner-top-left
            div.corner.corner-top
            div.corner.corner-top-right
            div.corner.corner-right
            div.corner.corner-bottom-right
            div.corner.corner-bottom
            div.corner.corner-bottom-left
            div.corner.corner-left
            div.iframe-container
                iframe
    */
    options = {...defaults, ...options};
    const stream = createElement("div", "stream");
    stream.setAttribute("data-streamer", streamer);
    const streamContent = createElement("div", "stream-content");
    //
    const videoOverlay = createElement("div", "video-overlay");
    videoOverlay.addEventListener("mouseup", (ev) => {
        focusStream(stream);
        if(ev.button === 0) enableIframeStream(stream);
    });
    streamContent.appendChild(videoOverlay);
    // titleBar start
    const titleBar = createElement("div", "title-bar");
    const title = createElement("span", "title");
    const titleControls = createElement("div", "controls");
    const btnMaximize = createElement("button", "btn-maximize");
    const btnClose = createElement("button", "btn-close");
    btnMaximize.addEventListener("mouseup", maximizeStream.bind(null, stream));
    btnClose.addEventListener("mouseup", closeStream.bind(null, stream));
    title.textContent = streamer;
    btnClose.innerHTML = "&times;";
    btnMaximize.textContent = "+";
    title.addEventListener("dblclick", maximizeStream.bind(null, stream));
    title.addEventListener("mousedown", startMove.bind(null, stream));
    titleBar.appendChild(title);
    titleControls.appendChild(btnMaximize);
    titleControls.appendChild(btnClose);
    titleBar.appendChild(titleControls);
    streamContent.appendChild(titleBar);
    // corner start
    const cornerTopLeft = createElement("div", "corner", "corner-top-left");
    const cornerTop = createElement("div", "corner", "corner-top");
    const cornerTopRight = createElement("div", "corner", "corner-top-right");
    const cornerRight = createElement("div", "corner", "corner-right");
    const cornerBottomRight = createElement("div", "corner", "corner-bottom-right");
    const cornerBottom = createElement("div", "corner", "corner-bottom");
    const cornerBottomLeft = createElement("div", "corner", "corner-bottom-left");
    const cornerLeft = createElement("div", "corner", "corner-left");
    cornerTopLeft.addEventListener("mousedown", startResize.bind(null, stream, 1, 1));
    cornerTop.addEventListener("mousedown", startResize.bind(null, stream, 1, 0));
    cornerTopRight.addEventListener("mousedown", startResize.bind(null, stream, 1, -1));
    cornerRight.addEventListener("mousedown", startResize.bind(null, stream, 0, -1));
    cornerBottomRight.addEventListener("mousedown", startResize.bind(null, stream, -1, -1));
    cornerBottom.addEventListener("mousedown", startResize.bind(null, stream, -1, 0));
    cornerBottomLeft.addEventListener("mousedown", startResize.bind(null, stream, -1, 1));
    cornerLeft.addEventListener("mousedown", startResize.bind(null, stream, 0, 1));
    streamContent.appendChild(cornerTopLeft);
    streamContent.appendChild(cornerTop);
    streamContent.appendChild(cornerTopRight);
    streamContent.appendChild(cornerRight);
    streamContent.appendChild(cornerBottomRight);
    streamContent.appendChild(cornerBottom);
    streamContent.appendChild(cornerBottomLeft);
    streamContent.appendChild(cornerLeft);
    // iframeContainer start
    const iframeContainer = createElement("div", "iframe-container");
    const iframe = createElement("iframe");
    iframe.src = `https://player.twitch.tv/?muted=false&channel=${streamer}&parent=${window.location.hostname}`;
    iframe.allowfullscreen = "false";
    iframeContainer.appendChild(iframe);
    streamContent.appendChild(iframeContainer);

    stream.appendChild(streamContent);
    streamsContainer.appendChild(stream);
    stream.style.width = options.streamWidth;
    stream.style.height = options.streamHeight;
    stream.style.top = options.streamTop;
    stream.style.left = options.streamLeft;
    stream.style.zIndex = options.streamZIndex;
    stream.setAttribute("data-last-bottom", options.streamLastBottom);
    stream.setAttribute("data-last-right", options.streamLastRight);
    stream.setAttribute("data-last-mt", options.streamLastMT);
    stream.setAttribute("data-last-ml", options.streamLastML);
    if(options.streamLastBottom !== "")
        repositionStream(stream);
    else
        setLastBottomRight(stream);

    // Focus
    focusStream(stream);
    stream.addEventListener("mousedown", (ev) => {
        focusStream(stream);
    });

    // Maximize
    if(options.streamMaximized) maximizeStream(stream);

    // Add to local storage
    updateStreamsCache();
};

// Read data
{
    const data = JSON.parse(localStorage.getItem("t3d-data"));
    if(data !== null) {
        for(let i = 0; i < data.length; i++) {
            addStream(data[i].streamer, {...defaults, ...data[i].options});
        }
    }
}

{ // Add Stream Modal
    const btnOK = addStreamModal.querySelector(".button-ok");
    const btnCancel = addStreamModal.querySelector(".button-cancel");
    const streamer = addStreamModal.querySelector("input[type='text']");
    const addStreamHelper = () => {
        if(streamer.value === "") {
        
            return;
        }
        addStream(streamer.value);
        streamer.value = "";
        addStreamModal.style.display = "";
    };
    addStreamModal.addEventListener("modalopen", (ev) => {
        addStreamModal.style.display = "block";
        streamer.focus();
    });
    addStreamModal.addEventListener("keyup", (ev) => {
        if(ev.key === "Enter") addStreamHelper();
    });
    btnOK.addEventListener("mouseup", addStreamHelper);
    btnCancel.addEventListener("mouseup", (ev) => {
        addStreamModal.style.display = "";
    });
}

        </script>
    </body>
</html>